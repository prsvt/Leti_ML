{
  "cells": [
    {
      "cell_type": "markdown",
      "id": "51ba79f2",
      "metadata": {
        "id": "51ba79f2"
      },
      "source": [
        "# ÐŸÑ€Ð¸Ð²ÐµÑ‚!\n",
        "\n",
        "ÐŸÐµÑ€ÐµÐ´ Ð½Ð°Ñ‡Ð°Ð»Ð¾Ð¼ Ð¿Ñ€Ð¾Ñ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ ÑƒÐ±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ, Ñ‡Ñ‚Ð¾ Ð²ÑÐµ Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐ½Ð¾ ÐºÐ°Ðº Ð½Ð°Ð´Ð¾. Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð°Ñ ÑÑ‡ÐµÐ¹ÐºÐ° Ð´Ð¾Ð»Ð¶Ð½Ð° Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒÑÑ Ð±ÐµÐ· Ð¾ÑˆÐ¸Ð±Ð¾Ðº:"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6a8428ea",
      "metadata": {
        "id": "6a8428ea"
      },
      "source": [
        "ÐŸÐ¾ÑÐ»Ðµ Ð¿Ñ€Ð¾Ñ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ Ð½Ðµ Ð·Ð°Ð±ÑƒÐ´ÑŒÑ‚Ðµ **Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ ÑÐ´Ñ€Ð¾** (**restart the kernel**) (Ð² Ð¿Ð°Ð½ÐµÐ»Ð¸ Ð¼ÐµÐ½ÑŽ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Kernel $\\rightarrow$ Restart) Ð¸ Ð·Ð°Ñ‚ÐµÐ¼ **Ð·Ð°Ð¿ÑƒÑÐº Ð²ÑÐµÑ… ÑÑ‡ÐµÐµÐº** (**run all cells**) (Ð² Ð¿Ð°Ð½ÐµÐ»Ð¸ Ð¼ÐµÐ½ÑŽ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Cell $\\rightarrow$ Run All).\n",
        "\n",
        "Ð£Ð±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ, Ñ‡Ñ‚Ð¾ Ð·Ð°Ð¼ÐµÐ½Ð¸Ð»Ð¸ Ð²ÑÐµ Ñ‚Ð°ÐºÐ¸Ðµ Ð¼ÐµÑÑ‚Ð° \n",
        "```python\n",
        "# YOUR CODE HERE\n",
        "raise NotImplementedError()\n",
        "```\n",
        "Ð¸\n",
        "```\n",
        "\"YOUR ANSWER HERE\"\n",
        "```\n",
        "Ð½Ð° ÑÐ²Ð¾Ð¸ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ Ð¸ Ð¾Ñ‚Ð²ÐµÑ‚Ñ‹.\n",
        "\n",
        "Ð•ÑÐ»Ð¸ Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹ ÐºÐ°ÐºÐ¸Ðµ-Ñ‚Ð¾ Ð¿Ð°ÐºÐµÑ‚Ñ‹, Ñ‚Ð¾ Ð¿Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ Ð½ÑƒÐ¶Ð½Ñ‹Ðµ Ð²ÐµÑ€ÑÐ¸Ð¸ Ð² Ð½Ð¾ÑƒÑ‚Ð±ÑƒÐºÐ°Ñ… Ð¿Ð¾ Ñ€ÐµÐ³Ñ€ÐµÑÑÐ¸Ð¸.\n",
        "\n",
        "ÐÐµ Ð·Ð°Ð±Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ Ð¾ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ñ… Ð¾ÑÐ¾Ð±ÐµÐ½Ð½Ð¾ÑÑ‚ÑÑ…:\n",
        "- ðŸ˜‰ ÐŸÐ¾Ð¼Ð¸Ð¼Ð¾ ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ñ‹Ñ… Ñ‚ÐµÑÑ‚Ð¾Ð² Ð¿Ð¾ÑÐ»Ðµ Ð·Ð°Ð´Ð°Ð½Ð¸Ñ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‚ Ð¸ ÑÐºÑ€Ñ‹Ñ‚Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ñ‹, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð²Ð½Ð¸Ð¼Ð°Ñ‚ÐµÐ»ÑŒÐ½ÐµÐµ Ñ‡Ð¸Ñ‚Ð°Ð¹Ñ‚Ðµ Ð·Ð°Ð´Ð°Ð½Ð¸Ðµ\n",
        "- ðŸ˜Ž ÐžÐ±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐ¹Ñ‚Ðµ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð½Ð° Ñ‚ÐµÑÑ‚Ð°Ñ…, Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ ÑÐ´Ñ€Ð¾ Ð¸ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ Ð²ÑÐµ ÑÑ‡ÐµÐ¹ÐºÐ¸ Ð·Ð°Ð½Ð¾Ð²Ð¾\n",
        "- ðŸ˜‚ ÐŸÐ¾ÑÐ»Ðµ ÑÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ñ Ð½Ð¾ÑƒÑ‚Ð±ÑƒÐºÐ¾Ð² Ð´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¼ÐµÑÑ‚Ð° Ð´Ð»Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð¾Ð² Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð¾ÑƒÑ‚Ð±ÑƒÐº Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾ (ÑÐ°Ð¼ Ð½Ð¾ÑƒÑ‚Ð±ÑƒÐº, Ð½Ðµ Ð² Ð°Ñ€Ñ…Ð¸Ð²Ðµ Ð¸ Ð½Ðµ Ð½Ð° GitHub)\n",
        "- ðŸ˜ˆ ÐÐµ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÐ¼ ÑƒÐ´Ð°Ð»ÑÑ‚ÑŒ Ð¸ÑÑ…Ð¾Ð´Ð½Ñ‹Ðµ ÑÑ‡ÐµÐ¹ÐºÐ¸, Ñ‚Ð°Ðº ÐºÐ°Ðº Ð¸Ð·-Ð·Ð° ÑÑ‚Ð¾Ð³Ð¾ Ð¼Ð¾Ð³ÑƒÑ‚ Ð½Ðµ Ð½Ð°Ñ‡Ð¸ÑÐ»Ð¸Ñ‚ÑŒÑÑ Ð±Ð°Ð»Ð»Ñ‹ =(\n",
        "  - ðŸ‘¼ Ð•ÑÐ»Ð¸ Ñ‚Ð°ÐºÐ¸ Ñ‚Ð°ÐºÐ¾Ðµ ÑÐ»ÑƒÑ‡Ð¸Ð»Ð¾ÑÑŒ, ÑÐºÐ°Ñ‡Ð°Ð¹Ñ‚Ðµ Ð·Ð°Ð½Ð¾Ð²Ð¾ ÑˆÐ°Ð±Ð»Ð¾Ð½ Ð¸ Ð¿ÐµÑ€ÐµÐ½ÐµÑÐ¸Ñ‚Ðµ Ð² Ð½ÐµÐ³Ð¾ ÑÐ²Ð¾Ð¸ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "d7f6b4d1",
      "metadata": {
        "id": "d7f6b4d1"
      },
      "source": [
        "---"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "1e47d973",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "markdown",
          "checksum": "037c897e7ae52a2adc17247bf70cf1ce",
          "grade": false,
          "grade_id": "cell-a157936eae072003",
          "locked": true,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "1e47d973"
      },
      "source": [
        "Ð­Ñ‚Ð¾ Ð²Ñ‚Ð¾Ñ€Ð°Ñ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒÐ½Ð°Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ð° Ñ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¼Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ð¼Ð¸ Ð¿Ð¾ Ñ‚ÐµÐ¼Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ñ€ÐµÐ³Ñ€ÐµÑÑÐ¸Ð¸ Ð² Ð¼Ð°ÑˆÐ¸Ð½Ð½Ð¾Ð¼ Ð¾Ð±ÑƒÑ‡ÐµÐ½Ð¸Ð¸!"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a063164d",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "e29e38031e6be94bc55218ebbd24173f",
          "grade": false,
          "grade_id": "cell-ea81f8cd8198e0b2",
          "locked": true,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "a063164d",
        "outputId": "eaafcfaa-0e8f-40e7-f2c3-8013cc3b7925"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "numpy version: 1.21.6\n",
            "pandas version: 1.3.5\n",
            "scikit-learn version: 1.0.2\n"
          ]
        }
      ],
      "source": [
        "import numpy as np\n",
        "print(f\"numpy version: {np.__version__}\")\n",
        "import pandas as pd\n",
        "print(f\"pandas version: {pd.__version__}\")\n",
        "# Just to check that it exists\n",
        "import sklearn\n",
        "print(f\"scikit-learn version: {sklearn.__version__}\")\n",
        "\n",
        "from typing import Tuple, List\n",
        "\n",
        "np.random.seed(123)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "dd7fa466",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "markdown",
          "checksum": "9bad05a1fa67e52f809c04eb6c522365",
          "grade": false,
          "grade_id": "cell-15c9325584b83940",
          "locked": true,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "dd7fa466"
      },
      "source": [
        "### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 1\n",
        "\n",
        "Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ…. Ð’ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ tuple Ñ DataFrame Ð¿Ñ€Ð¸Ð·Ð½Ð°ÐºÐ¾Ð² Ð¸ Series Ñ†ÐµÐ»ÐµÐ²Ð¾Ð¹ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ [ÑÑ‚Ñƒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ](https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_diabetes.html) Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð¾ÑÐ½Ð¾Ð²Ñ‹ Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð´Ð°Ñ‚Ð°ÑÐµÑ‚Ð° Ð´Ð¸Ð°Ð±ÐµÑ‚Ð¾Ð².\n",
        "\n",
        "> Ð­Ñ‚Ð¾ Ð¾Ñ‡ÐµÐ½ÑŒ Ð¿Ñ€Ð¾ÑÑ‚Ð°Ñ Ð·Ð°Ð´Ð°Ñ‡Ð°, Ð½Ð¾ ÐµÐµ Ð²Ð°Ð¶Ð½Ð¾ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ, Ñ‚Ð°Ðº ÐºÐ°Ðº Ð¾Ð½Ð° Ð±ÑƒÐ´ÐµÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒÑÑ Ð´Ð°Ð»ÐµÐµ Ð¿Ð¾ Ñ‚ÐµÑÑ‚Ð°Ð¼!"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3377bf31",
      "metadata": {
        "deletable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "1b964b03c507f5d1defb738609f632ca",
          "grade": false,
          "grade_id": "cell-327093fec6a96199",
          "locked": false,
          "schema_version": 3,
          "solution": true,
          "task": false
        },
        "id": "3377bf31"
      },
      "outputs": [],
      "source": [
        "from sklearn import datasets as ds\n",
        "def load_data() -> Tuple[pd.DataFrame, pd.Series]:\n",
        "    df = ds.load_diabetes(return_X_y = True, as_frame =  True)\n",
        "    return df\n",
        "\n",
        "  "
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7243ab44",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "ea7287163448fe2038965ebc027c44e8",
          "grade": true,
          "grade_id": "cell-7e627329ed2ea656",
          "locked": true,
          "points": 1,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "7243ab44"
      },
      "outputs": [],
      "source": [
        "X, y = load_data()\n",
        "\n",
        "np.testing.assert_array_equal(X.shape, [442, 10])\n",
        "np.testing.assert_array_equal(y.shape, [442])\n",
        "\n",
        "assert isinstance(X, pd.DataFrame)\n",
        "assert isinstance(y, pd.Series)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e8481cc6",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "markdown",
          "checksum": "96be49d0df0614df2ae7e0b11aa3745b",
          "grade": false,
          "grade_id": "cell-cd2553f9a8f3b884",
          "locked": true,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "e8481cc6"
      },
      "source": [
        "### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 2\n",
        "\n",
        "Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð¿Ð¾Ð¸ÑÐºÐ° Ð¿Ñ€Ð¸Ð·Ð½Ð°ÐºÐ¾Ð² Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸ÐµÐ¹ Ð¿Ð¾ Ð¡Ð¿Ð¸Ñ€Ð¼Ð°Ð½Ñƒ Ð²Ñ‹ÑˆÐµ Ð¿Ð¾Ñ€Ð¾Ð³Ð° Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹.\n",
        "\n",
        "ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¸Ð¼ÐµÐ½ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ…. Ð¡Ð°Ð¼Ñƒ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð¸ÑÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ (Ñ‚Ð°Ðº ÐºÐ°Ðº ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ñ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ ÑÐ°Ð¼Ð¾Ð³Ð¾ ÑÐµÐ±Ñ Ð²ÑÐµÐ³Ð´Ð° = 1)."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d1222cd0",
      "metadata": {
        "deletable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "db0f149e343be450a678bc678d2bc316",
          "grade": false,
          "grade_id": "cell-7bd0359336964ee1",
          "locked": false,
          "schema_version": 3,
          "solution": true,
          "task": false
        },
        "id": "d1222cd0"
      },
      "outputs": [],
      "source": [
        "def get_high_correlation_features(df: pd.DataFrame, col_name: str, threshold: float) -> List[str]:\n",
        "    corr_mtrx = df.corr(method = 'spearman') \n",
        "    mask = (abs(corr_mtrx[col_name]) > threshold) & (corr_mtrx[col_name] != 1)\n",
        "    return_list = corr_mtrx[mask]\n",
        "    return return_list.index"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "eb1fde6d",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "465795194d29b871f0757f6e8e2c7fcf",
          "grade": true,
          "grade_id": "cell-136b84cd0900ad11",
          "locked": true,
          "points": 2,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "eb1fde6d"
      },
      "outputs": [],
      "source": [
        "X, y = load_data()\n",
        "df = X.copy()\n",
        "df['target'] = y\n",
        "\n",
        "_test_data = get_high_correlation_features(df, \"target\", threshold=0.35)\n",
        "np.testing.assert_equal(\n",
        "    _test_data, \n",
        "    np.array(['bmi', 'bp', 's3', 's4', 's5', 's6'])\n",
        ")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0a6b4fcd",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "markdown",
          "checksum": "c6a861e043b44b88965172e59e92d771",
          "grade": false,
          "grade_id": "cell-4de8ba55b701b6a6",
          "locked": true,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "0a6b4fcd"
      },
      "source": [
        "### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 3\n",
        "\n",
        "Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ ÐºÐ»Ð°ÑÑ Ð´Ð»Ñ Ð¿Ñ€ÐµÐ´Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ…. ÐŸÑ€ÐµÐ´Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð´Ð¾Ð»Ð¶Ð½Ð° Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ‚ÑŒ Ð² ÑÐµÐ±Ñ:\n",
        "- ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ 1Ð³Ð¾ Ð¸ 3Ð³Ð¾ ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ð»ÐµÐ¹ Ð¿Ð¾ ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñƒ Ð¿Ñ€Ð¸Ð·Ð½Ð°ÐºÑƒ Ð¸ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð·Ð° Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ð¼Ð¸ ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ð»ÐµÐ¹ Ð¿Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÑÐ¼ Ð¿Ñ€Ð¸Ð·Ð½Ð°ÐºÐ°. Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð±Ð¾Ð»ÑŒÑˆÐµ 3Ð³Ð¾ Ð¸ Ð¼ÐµÐ½ÑŒÑˆÐµ 1Ð³Ð¾ ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ð»ÐµÐ¹ (Ð½Ðµ Ñ€Ð°Ð²Ð½Ð¾).\n",
        "- ÐœÐ°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¸Ð·Ð½Ð°ÐºÐ¾Ð² Ðº Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ð¼ [-1; 2]\n",
        "- Ð£Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼Ð°Ñ Ñ‡Ð¸ÑÑ‚ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ…, Ð¿Ð¾Ð´Ð°Ð²Ð°ÐµÐ¼Ñ‹Ñ… Ð² transform\n",
        "\n",
        "> ÐžÐ±Ñ€Ð°Ñ‚Ð¸Ñ‚Ðµ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ, Ð½Ð° ÐºÐ°ÐºÐ¸Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð¾Ð»Ð¶ÐµÐ½ ÑƒÑ‡Ð¸Ñ‚ÑŒÑÑ scaler Ð¸ Ð² ÐºÐ°ÐºÐ¾Ð¼ Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð¸Ð´Ñ‚Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð² transform()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c91386a1",
      "metadata": {
        "deletable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "4aa2d73ba8b04a987539b5999a478d69",
          "grade": false,
          "grade_id": "cell-0da59aa4e9b3e30e",
          "locked": false,
          "schema_version": 3,
          "solution": true,
          "task": false
        },
        "id": "c91386a1"
      },
      "outputs": [],
      "source": [
        "from sklearn.preprocessing import MinMaxScaler\n",
        "\n",
        "class DataPreprocessing:\n",
        "    def __init__(self, quartile_clean_col_name: str):\n",
        "       self.scaler = MinMaxScaler(feature_range = (-1, 2))\n",
        "       self.name = quartile_clean_col_name\n",
        "       pass\n",
        "        \n",
        "    def fit(self, X: pd.DataFrame) -> None:\n",
        "      self.df_copy = X.copy()\n",
        "      self.quan3 = self.df_copy[self.name].quantile(q = 0.75)\n",
        "      self.quan1 = self.df_copy[self.name].quantile(q = 0.25)\n",
        "      mask1  = self.df_copy[self.name] <= self.quan3\n",
        "      mask2  = self.df_copy[self.name] >= self.quan1\n",
        "      self.scaler.fit(self.df_copy[mask1 & mask2])\n",
        "\n",
        "      pass\n",
        "        \n",
        "    def transform(self, X: pd.DataFrame, clean_data: bool = False) -> pd.DataFrame:\n",
        "      res = X.copy()\n",
        "      if(clean_data == True):\n",
        "        mask1  = res[self.name] <= self.quan3\n",
        "        mask2  = res[self.name] >= self.quan1\n",
        "        res = res[(mask1 & mask2)]\n",
        "      trans_res = self.scaler.transform(res)\n",
        "      for i in range(len(res.columns)):\n",
        "        res.iloc[:,i ] = trans_res[:,i]\n",
        "      return res"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5e55dda2",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "edaeb2eefcc7d2f461ca7e95d4472a5d",
          "grade": true,
          "grade_id": "cell-9e66830003060afc",
          "locked": true,
          "points": 4,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "5e55dda2"
      },
      "outputs": [],
      "source": [
        "X, y = load_data()\n",
        "\n",
        "_X_train_part = X.iloc[:350]\n",
        "_X_test_part = X.iloc[350:]\n",
        "\n",
        "preprocess = DataPreprocessing(quartile_clean_col_name='s2')\n",
        "preprocess.fit(_X_train_part)\n",
        "_X_test_prep = preprocess.transform(_X_test_part, clean_data=True)\n",
        "\n",
        "assert isinstance(_X_test_prep, pd.DataFrame)\n",
        "np.testing.assert_array_equal(_X_test_prep.shape, (44, 10))\n",
        "np.testing.assert_array_equal(_X_test_prep.columns, X.columns)\n",
        "assert 1.98 < _X_test_prep[\"s5\"].max() < 2\n",
        "assert _X_test_prep[\"s4\"].max() > 1\n",
        "\n",
        "np.testing.assert_almost_equal(_X_test_prep[\"bp\"].mean(), 0.384, decimal=2)\n",
        "\n",
        "# Check that index have to be saved from original data\n",
        "assert 440 < _X_test_prep.index.max() <= 450\n",
        "assert 350 <= _X_test_prep.index.min() < 360\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "77ad6069",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "markdown",
          "checksum": "331c16d29340c722b5614d7f159cb5c9",
          "grade": false,
          "grade_id": "cell-f4e56816d00eb2d3",
          "locked": true,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "77ad6069"
      },
      "source": [
        "### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 4\n",
        "\n",
        "Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ ÐºÐ»Ð°ÑÑ Ð´Ð»Ñ Ð¾Ð±ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¼Ð¾Ð´ÐµÐ»Ð¸ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ð¹ Ñ€ÐµÐ³Ñ€ÐµÑÑÐ¸Ð¸ Ñ Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸ÐµÐ¼ Ð¼ÐµÑ‚Ñ€Ð¸Ðº. Ð’ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð²Ñ…Ð¾Ð´Ð¸Ñ‚ÑŒ: MSE, RMSE, MAE, R^2."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 15,
      "id": "37258376",
      "metadata": {
        "deletable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "717cf2be7d3e6de9821937005984c4ec",
          "grade": false,
          "grade_id": "cell-dfe13046beea8fba",
          "locked": false,
          "schema_version": 3,
          "solution": true,
          "task": false
        },
        "id": "37258376"
      },
      "outputs": [],
      "source": [
        "from sklearn.preprocessing import MinMaxScaler\n",
        "from sklearn.linear_model import LinearRegression\n",
        "from sklearn.metrics import r2_score\n",
        "from sklearn.metrics import mean_absolute_error\n",
        "from sklearn.metrics import mean_squared_error\n",
        "\n",
        "class ModelTrainWithMetrics:\n",
        "    def fit(self, X: pd.DataFrame, y: pd.Series) -> None:\n",
        "        self.lin_reg = LinearRegression()\n",
        "        self.lin_reg.fit(X, y)\n",
        "        \n",
        "    def predict_evaluate(self, X: pd.DataFrame, y: pd.Series) -> Tuple[np.ndarray, dict]:\n",
        "        self.y_pred = self.lin_reg.predict(X)\n",
        "        \n",
        "        self.y_true = y\n",
        "        series = {\n",
        "            'mse': mean_squared_error(self.y_true, self.y_pred),\n",
        "            'mae': mean_absolute_error(self.y_true, self.y_pred),\n",
        "            'rmse': np.sqrt(mean_squared_error(self.y_true, self.y_pred)),\n",
        "            'r2':r2_score(self.y_true, self.y_pred)\n",
        "\n",
        "        }\n",
        "        return self.y_pred, series"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 16,
      "id": "700711d3",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "8e56201b868ea5eee10d9f4ef0e6f928",
          "grade": true,
          "grade_id": "cell-c32a1f863b463294",
          "locked": true,
          "points": 3,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "700711d3"
      },
      "outputs": [],
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X, y = load_data()\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, shuffle=True, test_size=0.3)\n",
        "\n",
        "model = ModelTrainWithMetrics()\n",
        "model.fit(X_train, y_train)\n",
        "y_test_pred, metrics = model.predict_evaluate(X_test, y_test)\n",
        "\n",
        "assert isinstance(metrics, dict)\n",
        "assert isinstance(y_test_pred, np.ndarray)\n",
        "np.testing.assert_equal(set(metrics.keys()), set(['mse', 'mae', 'rmse', 'r2']))\n",
        "\n",
        "assert metrics['r2'] > 0.45\n",
        "assert metrics['rmse'] < 55\n",
        "assert metrics['mae'] < 45\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ab109727",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "markdown",
          "checksum": "f88583ce4dbadf7fdda9764ee47b9cec",
          "grade": false,
          "grade_id": "cell-8963be98c2d31921",
          "locked": true,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "ab109727"
      },
      "source": [
        "### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 5\n",
        "\n",
        "Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ ÑÐ±Ð¾Ñ€Ð° ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð°Ñ‚Ð°ÑÐµÑ‚Ð° Ð¿Ð¾ ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ñ‡Ð¸ÑÐ»Ð¾Ð²Ð¾Ð¹ ÐºÐ¾Ð»Ð¾Ð½ÐºÐµ.\n",
        "\n",
        "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ Ð²Ñ‹Ñ…Ð¾Ð´Ð°: ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸ ~ Ð¿Ð¾ÐºÐ°Ð·Ð°Ñ‚ÐµÐ»Ð¸, ÑÑ‚Ñ€Ð¾ÐºÐ¸ ~ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ð¸ÑÑ…Ð¾Ð´Ð½Ñ‹Ñ… ÐºÐ¾Ð»Ð¾Ð½Ð¾Ðº.\n",
        "\n",
        "Ð¢Ñ€ÐµÐ±ÑƒÐµÐ¼Ñ‹Ðµ Ð¿Ð¾ÐºÐ°Ð·Ð°Ñ‚ÐµÐ»Ð¸:\n",
        "- ÐœÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸\n",
        "- ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸\n",
        "- ÐœÐµÐ´Ð¸Ð°Ð½Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸\n",
        "- Ð¡Ñ€ÐµÐ´Ð½ÐµÐµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸ / Mean value\n",
        "- Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ðµ (Ð¡Ñ€ÐµÐ´Ð½ÐµÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ) Ð¾Ñ‚ÐºÐ»Ð¾Ð½ÐµÐ½Ð¸Ðµ / Standart deviation\n",
        "- ÐŸÐµÑ€Ð²Ñ‹Ð¹ ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ð»ÑŒ\n",
        "- Ð¢Ñ€ÐµÑ‚Ð¸Ð¹ ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ð»ÑŒ\n",
        "- Ð˜Ð½Ñ‚ÐµÑ€ÐºÐ²Ð°Ñ€Ñ‚Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ Ñ€Ð°Ð·Ð¼Ð°Ñ… (IQR ~ Interquartile range)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6163b336",
      "metadata": {
        "deletable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "be165ac660534a1082304bc806111a82",
          "grade": false,
          "grade_id": "cell-20d8e9a92c0f2714",
          "locked": false,
          "schema_version": 3,
          "solution": true,
          "task": false
        },
        "id": "6163b336"
      },
      "outputs": [],
      "source": [
        "def collect_statistics(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    # YOUR CODE HERE\n",
        "    raise NotImplementedError()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8fb8b704",
      "metadata": {
        "deletable": false,
        "editable": false,
        "nbgrader": {
          "cell_type": "code",
          "checksum": "56a0d00e03f858dace16dd28077e3b68",
          "grade": true,
          "grade_id": "cell-146d7f58a0e36598",
          "locked": true,
          "points": 2,
          "schema_version": 3,
          "solution": false,
          "task": false
        },
        "id": "8fb8b704"
      },
      "outputs": [],
      "source": [
        "X, _ = load_data()\n",
        "\n",
        "stats = collect_statistics(X)\n",
        "\n",
        "np.testing.assert_equal(set(stats.index), set(['age', 'sex', 'bmi', 'bp', 's1', 's2', 's3', 's4', 's5', 's6']))\n",
        "np.testing.assert_equal(set(stats.columns), set(['min', 'max', 'median', 'mean', 'std', 'Q1', 'Q3', 'IQR']))\n",
        "\n",
        "np.testing.assert_almost_equal(stats.loc[['age', 'bmi'], 'mean'], [0, 0], decimal=2)\n",
        "np.testing.assert_almost_equal(stats.loc[['s3', 'bp'], 'std'], [0.048, 0.048], decimal=2)\n",
        "np.testing.assert_almost_equal(stats.loc[['s6', 's5'], 'min'], [-0.138, -0.126], decimal=2)\n",
        "np.testing.assert_almost_equal(stats.loc[['s1', 's2'], 'max'], [0.154, 0.199], decimal=2)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7ad1d0f5",
      "metadata": {
        "id": "7ad1d0f5"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.12"
    },
    "vscode": {
      "interpreter": {
        "hash": "5ef4d00d2bd0c756646408250b3e0222db1655439c25a4f11279476b8286db07"
      }
    },
    "colab": {
      "provenance": []
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
